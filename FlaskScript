#!/usr/bin/env python3
"""
Remote Script Execution Utility
A web-based application for executing shell scripts on remote Unix hosts via SSH
with interactive input handling and real-time output capture.
"""

import os
import threading
import time
import select
from datetime import datetime
from flask import Flask, render_template, request, session, jsonify
from flask_session import Session
from flask_socketio import SocketIO, emit
import paramiko
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-change-in-production'
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = False

# Initialize session and socketio
Session(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# Configuration
DEFAULT_SCRIPT_PATH = '/path/to/script.sh'
DEFAULT_OUTPUT_DIR = './output'
HOSTS = ['192.168.1.100', 'localhost', 'server1.example.com']
SSH_TIMEOUT = 300
BUFFER_SIZE = 65536

# Ensure output directory exists
os.makedirs(DEFAULT_OUTPUT_DIR, exist_ok=True)

class SSHExecutor:
    def __init__(self, host, username, password, script_path, output_path):
        self.host = host
        self.username = username
        self.password = password
        self.script_path = script_path
        self.output_path = output_path
        self.client = None
        self.channel = None
        self.output_file = None
        self.execution_thread = None
        self.stop_execution = False
        
    def connect(self):
        """Establish SSH connection"""
        try:
            socketio.emit('progress', {'percent': 5, 'message': 'Connecting to host...'})
            
            self.client = paramiko.SSHClient()
            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.client.connect(
                hostname=self.host,
                username=self.username,
                password=self.password,
                timeout=30
            )
            
            socketio.emit('progress', {'percent': 15, 'message': 'Connected successfully'})
            return True
            
        except Exception as e:
            error_msg = f"SSH connection failed: {str(e)}"
            logger.error(error_msg)
            socketio.emit('error', {'message': error_msg})
            return False
    
    def verify_script(self):
        """Verify script exists and is executable"""
        try:
            socketio.emit('progress', {'percent': 20, 'message': 'Verifying script...'})
            
            # Check if script exists
            stdin, stdout, stderr = self.client.exec_command(f'test -f {self.script_path}')
            if stdout.channel.recv_exit_status() != 0:
                raise Exception(f"Script not found: {self.script_path}")
            
            # Check if script is executable
            stdin, stdout, stderr = self.client.exec_command(f'test -x {self.script_path}')
            if stdout.channel.recv_exit_status() != 0:
                raise Exception(f"Script is not executable: {self.script_path}")
            
            socketio.emit('progress', {'percent': 25, 'message': 'Script verified'})
            return True
            
        except Exception as e:
            error_msg = f"Script verification failed: {str(e)}"
            logger.error(error_msg)
            socketio.emit('error', {'message': error_msg})
            return False
    
    def execute_script(self):
        """Execute the script with interactive input handling"""
        try:
            socketio.emit('progress', {'percent': 30, 'message': 'Starting script execution...'})
            
            # Open output file
            self.output_file = open(self.output_path, 'w', encoding='utf-8', buffering=1)
            self.output_file.write(f"Script execution started at {datetime.now()}\n")
            self.output_file.write(f"Host: {self.host}\n")
            self.output_file.write(f"Script: {self.script_path}\n")
            self.output_file.write("-" * 50 + "\n")
            
            # Create interactive shell
            self.channel = self.client.invoke_shell()
            self.channel.settimeout(1.0)
            
            # Execute the script
            command = f'bash {self.script_path}\n'
            self.channel.send(command)
            
            # Start execution monitoring
            self.execution_thread = threading.Thread(target=self._monitor_execution)
            self.execution_thread.daemon = True
            self.execution_thread.start()
            
            return True
            
        except Exception as e:
            error_msg = f"Script execution failed: {str(e)}"
            logger.error(error_msg)
            socketio.emit('error', {'message': error_msg})
            return False
    
    def _monitor_execution(self):
        """Monitor script execution and handle input/output"""
        try:
            buffer = ""
            start_time = time.time()
            last_output_time = time.time()
            
            while not self.stop_execution:
                # Check for timeout
                if time.time() - start_time > SSH_TIMEOUT:
                    socketio.emit('error', {'message': 'Script execution timeout'})
                    break
                
                # Update progress based on time
                elapsed = time.time() - start_time
                progress = min(30 + (elapsed / SSH_TIMEOUT) * 60, 90)
                
                try:
                    if self.channel.recv_ready():
                        data = self.channel.recv(BUFFER_SIZE).decode('utf-8', errors='ignore')
                        if data:
                            buffer += data
                            last_output_time = time.time()
                            
                            # Process complete lines
                            while '\n' in buffer:
                                line, buffer = buffer.split('\n', 1)
                                self._process_output_line(line + '\n')
                            
                            # Update progress
                            socketio.emit('progress', {
                                'percent': int(progress),
                                'message': 'Executing script...'
                            })
                    
                    # Check if script is waiting for input
                    if buffer and self._is_waiting_for_input(buffer):
                        socketio.emit('waiting_for_input', {'prompt': buffer.strip()})
                        # Don't process this as output yet, wait for input
                        continue
                    
                    # Check if channel is closed
                    if self.channel.exit_status_ready():
                        # Process any remaining buffer
                        if buffer:
                            self._process_output_line(buffer)
                        break
                    
                    # Check for inactivity (script might be done)
                    if time.time() - last_output_time > 5 and not buffer:
                        if self.channel.exit_status_ready():
                            break
                
                except Exception as e:
                    if "timed out" not in str(e).lower():
                        logger.error(f"Error in monitoring: {e}")
                
                time.sleep(0.1)
            
            # Script completed
            socketio.emit('progress', {'percent': 100, 'message': 'Script execution completed'})
            socketio.emit('execution_complete')
            
            if self.output_file:
                self.output_file.write(f"\nScript execution completed at {datetime.now()}\n")
                self.output_file.close()
                
        except Exception as e:
            error_msg = f"Execution monitoring error: {str(e)}"
            logger.error(error_msg)
            socketio.emit('error', {'message': error_msg})
    
    def _process_output_line(self, line):
        """Process and emit a line of output"""
        # Write to file
        if self.output_file:
            self.output_file.write(line)
            self.output_file.flush()
        
        # Emit to web interface
        socketio.emit('output', {'data': line})
    
    def _is_waiting_for_input(self, buffer):
        """Check if the script is waiting for user input"""
        # Common input prompts
        input_indicators = [':', '?', 'enter', 'input', 'Enter', 'Input', 'Password']
        buffer_lower = buffer.lower().strip()
        
        # Check if it ends with common prompt indicators
        return any(buffer_lower.endswith(indicator.lower()) for indicator in input_indicators)
    
    def send_input(self, user_input):
        """Send user input to the script"""
        try:
            if self.channel and not self.channel.closed:
                input_line = user_input + '\n'
                self.channel.send(input_line)
                
                # Log the input
                if self.output_file:
                    self.output_file.write(f"User input: {user_input}\n")
                    self.output_file.flush()
                
                socketio.emit('output', {'data': f"User input: {user_input}\n"})
                return True
        except Exception as e:
            logger.error(f"Error sending input: {e}")
            return False
        return False
    
    def cleanup(self):
        """Clean up resources"""
        self.stop_execution = True
        
        if self.channel:
            self.channel.close()
        
        if self.client:
            self.client.close()
        
        if self.output_file and not self.output_file.closed:
            self.output_file.close()

# Global executor instance
current_executor = None

@app.route('/')
def index():
    """Main page"""
    # Get saved credentials from session
    username = session.get('username', '')
    password = session.get('password', '')
    
    # Generate default output path
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    default_output = os.path.join(DEFAULT_OUTPUT_DIR, f'output_{timestamp}.txt')
    
    return render_template('index.html',
                         hosts=HOSTS,
                         default_script_path=DEFAULT_SCRIPT_PATH,
                         default_output_path=default_output,
                         saved_username=username,
                         saved_password=password)

@app.route('/validate', methods=['POST'])
def validate_inputs():
    """Validate form inputs"""
    data = request.json
    errors = []
    
    if not data.get('username'):
        errors.append('Username is required')
    
    if not data.get('password'):
        errors.append('Password is required')
    
    if not data.get('host'):
        errors.append('Host is required')
    
    if not data.get('script_path'):
        errors.append('Script path is required')
    
    if not data.get('output_path'):
        errors.append('Output path is required')
    
    # Validate output directory exists
    output_dir = os.path.dirname(data.get('output_path', ''))
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir, exist_ok=True)
        except Exception as e:
            errors.append(f'Cannot create output directory: {str(e)}')
    
    return jsonify({'valid': len(errors) == 0, 'errors': errors})

@socketio.on('execute_script')
def handle_execute_script(data):
    """Handle script execution request"""
    global current_executor
    
    try:
        # Save credentials to session
        session['username'] = data['username']
        session['password'] = data['password']
        
        # Clean up previous executor
        if current_executor:
            current_executor.cleanup()
        
        # Create new executor
        current_executor = SSHExecutor(
            host=data['host'],
            username=data['username'],
            password=data['password'],
            script_path=data['script_path'],
            output_path=data['output_path']
        )
        
        # Execute in separate thread
        def execute():
            if current_executor.connect():
                if current_executor.verify_script():
                    current_executor.execute_script()
        
        execution_thread = threading.Thread(target=execute)
        execution_thread.daemon = True
        execution_thread.start()
        
    except Exception as e:
        emit('error', {'message': f'Execution failed: {str(e)}'})

@socketio.on('send_input')
def handle_send_input(data):
    """Handle user input for the script"""
    global current_executor
    
    if current_executor:
        user_input = data.get('input', '')
        current_executor.send_input(user_input)

@socketio.on('stop_execution')
def handle_stop_execution():
    """Handle stop execution request"""
    global current_executor
    
    if current_executor:
        current_executor.cleanup()
        emit('execution_stopped')

if __name__ == '__main__':
    print("Starting Remote Script Execution Utility...")
    print(f"Default script path: {DEFAULT_SCRIPT_PATH}")
    print(f"Default output directory: {DEFAULT_OUTPUT_DIR}")
    print(f"Available hosts: {', '.join(HOSTS)}")
    print("Access the application at: http://localhost:5000")
    
    socketio.run(app, debug=True, host='0.0.0.0', port=5000)


--------------


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Script Execution Utility</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .container {
            padding: 2rem 0;
        }

        .card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
        }

        .card-header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            border-radius: 15px 15px 0 0 !important;
            padding: 1.5rem;
        }

        .form-control, .form-select {
            border-radius: 10px;
            border: 2px solid #e2e8f0;
            padding: 0.75rem 1rem;
            transition: all 0.3s ease;
        }

        .form-control:focus, .form-select:focus {
            border-color: #4f46e5;
            box-shadow: 0 0 0 0.2rem rgba(79, 70, 229, 0.25);
        }

        .btn-primary {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            border: none;
            border-radius: 10px;
            padding: 0.75rem 2rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 70, 229, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border: none;
            border-radius: 10px;
            padding: 0.75rem 2rem;
            font-weight: 600;
        }

        .progress {
            height: 25px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.3);
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            transition: width 0.5s ease;
            border-radius: 15px;
        }

        #output {
            background: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 10px;
            border: 2px solid #333;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group-text {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            border: none;
            border-radius: 10px 0 0 10px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-disconnected { background-color: #ef4444; }
        .status-connecting { background-color: #f59e0b; }
        .status-connected { background-color: #10b981; }

        .alert {
            border-radius: 10px;
            border: none;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .execution-controls {
            display: none;
            padding: 1rem;
            background: rgba(249, 250, 251, 0.8);
            border-radius: 10px;
            margin-top: 1rem;
        }

        .input-prompt {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        #userInput {
            border: 2px solid #f59e0b;
        }

        #userInput:focus {
            border-color: #d97706;
            box-shadow: 0 0 0 0.2rem rgba(245, 158, 11, 0.25);
        }

        .spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-lg-10">
                <div class="card fade-in">
                    <div class="card-header text-center">
                        <h2 class="mb-0">
                            <i class="fas fa-terminal me-2"></i>
                            Remote Script Execution Utility
                        </h2>
                        <p class="mb-0 mt-2 opacity-75">Execute shell scripts on remote Unix hosts via SSH</p>
                    </div>
                    <div class="card-body p-4">
                        <!-- Connection Status -->
                        <div class="mb-3">
                            <span class="status-indicator status-disconnected" id="statusIndicator"></span>
                            <span id="statusText">Disconnected</span>
                        </div>

                        <!-- Main Form -->
                        <form id="executionForm">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="input-group mb-3">
                                        <span class="input-group-text">
                                            <i class="fas fa-user"></i>
                                        </span>
                                        <input type="text" class="form-control" id="username" 
                                               placeholder="SSH Username" value="{{ saved_username }}" required>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="input-group mb-3">
                                        <span class="input-group-text">
                                            <i class="fas fa-lock"></i>
                                        </span>
                                        <input type="password" class="form-control" id="password" 
                                               placeholder="SSH Password" value="{{ saved_password }}" required>
                                    </div>
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-md-6">
                                    <div class="input-group mb-3">
                                        <span class="input-group-text">
                                            <i class="fas fa-server"></i>
                                        </span>
                                        <select class="form-select" id="host" required>
                                            <option value="">Select Host</option>
                                            {% for host in hosts %}
                                            <option value="{{ host }}">{{ host }}</option>
                                            {% endfor %}
                                        </select>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="input-group mb-3">
                                        <span class="input-group-text">
                                            <i class="fas fa-file-code"></i>
                                        </span>
                                        <input type="text" class="form-control" id="scriptPath" 
                                               placeholder="Remote Script Path" value="{{ default_script_path }}" required>
                                    </div>
                                </div>
                            </div>

                            <div class="input-group mb-3">
                                <span class="input-group-text">
                                    <i class="fas fa-save"></i>
                                </span>
                                <input type="text" class="form-control" id="outputPath" 
                                       placeholder="Local Output File Path" value="{{ default_output_path }}" required>
                            </div>

                            <!-- Execute Button -->
                            <div class="text-center mb-4">
                                <button type="submit" class="btn btn-primary btn-lg me-3" id="executeBtn">
                                    <i class="fas fa-play me-2"></i>Execute Script
                                </button>
                                <button type="button" class="btn btn-danger btn-lg" id="stopBtn" style="display: none;">
                                    <i class="fas fa-stop me-2"></i>Stop Execution
                                </button>
                            </div>
                        </form>

                        <!-- Progress Bar -->
                        <div class="mb-4" id="progressContainer" style="display: none;">
                            <div class="progress">
                                <div class="progress-bar" id="progressBar" role="progressbar" 
                                     style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                                    <span id="progressText">Ready</span>
                                </div>
                            </div>
                        </div>

                        <!-- Error Messages -->
                        <div id="errorContainer"></div>

                        <!-- Execution Controls -->
                        <div class="execution-controls" id="executionControls">
                            <div id="inputPrompt" class="input-prompt" style="display: none;"></div>
                            <div class="input-group" id="inputGroup" style="display: none;">
                                <input type="text" class="form-control" id="userInput" 
                                       placeholder="Enter your input here...">
                                <button class="btn btn-warning" type="button" id="sendInputBtn">
                                    <i class="fas fa-paper-plane"></i> Send
                                </button>
                            </div>
                        </div>

                        <!-- Output Display -->
                        <div class="mt-4">
                            <h5><i class="fas fa-terminal me-2"></i>Script Output</h5>
                            <div id="output" class="form-control p-3">Waiting for execution...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    
    <script>
        // Initialize Socket.IO
        const socket = io();
        
        // DOM elements
        const form = document.getElementById('executionForm');
        const executeBtn = document.getElementById('executeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const output = document.getElementById('output');
        const errorContainer = document.getElementById('errorContainer');
        const executionControls = document.getElementById('executionControls');
        const inputPrompt = document.getElementById('inputPrompt');
        const inputGroup = document.getElementById('inputGroup');
        const userInput = document.getElementById('userInput');
        const sendInputBtn = document.getElementById('sendInputBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');

        let isExecuting = false;

        // Form submission
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (isExecuting) return;

            const formData = {
                username: document.getElementById('username').value,
                password: document.getElementById('password').value,
                host: document.getElementById('host').value,
                script_path: document.getElementById('scriptPath').value,
                output_path: document.getElementById('outputPath').value
            };

            // Validate inputs
            try {
                const response = await fetch('/validate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });
                
                const result = await response.json();
                
                if (!result.valid) {
                    showError(result.errors.join('<br>'));
                    return;
                }
            } catch (error) {
                showError('Validation failed: ' + error.message);
                return;
            }

            // Clear previous output and errors
            clearError();
            output.textContent = 'Starting execution...\n';
            
            // Start execution
            startExecution();
            socket.emit('execute_script', formData);
        });

        // Stop button
        stopBtn.addEventListener('click', () => {
            socket.emit('stop_execution');
            stopExecution();
        });

        // Send input button
        sendInputBtn.addEventListener('click', () => {
            sendUserInput();
        });

        // Enter key for input
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendUserInput();
            }
        });

        function sendUserInput() {
            const input = userInput.value.trim();
            if (input) {
                socket.emit('send_input', { input: input });
                userInput.value = '';
                hideInputPrompt();
            }
        }

        function startExecution() {
            isExecuting = true;
            executeBtn.disabled = true;
            executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Executing...';
            stopBtn.style.display = 'inline-block';
            progressContainer.style.display = 'block';
            executionControls.style.display = 'block';
            
            updateStatus('connecting', 'Connecting...');
        }

        function stopExecution() {
            isExecuting = false;
            executeBtn.disabled = false;
            executeBtn.innerHTML = '<i class="fas fa-play me-2"></i>Execute Script';
            stopBtn.style.display = 'none';
            hideInputPrompt();
            
            updateStatus('disconnected', 'Disconnected');
        }

        function updateStatus(status, text) {
            statusIndicator.className = `status-indicator status-${status}`;
            statusText.textContent = text;
        }

        function showInputPrompt(prompt) {
            inputPrompt.textContent = prompt;
            inputPrompt.style.display = 'block';
            inputGroup.style.display = 'flex';
            userInput.focus();
        }

        function hideInputPrompt() {
            inputPrompt.style.display = 'none';
            inputGroup.style.display = 'none';
        }

        function showError(message) {
            errorContainer.innerHTML = `
                <div class="alert alert-danger alert-dismissible fade show" role="alert">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
        }

        function clearError() {
            errorContainer.innerHTML = '';
        }

        // Socket event handlers
        socket.on('progress', (data) => {
            progressBar.style.width = data.percent + '%';
            progressBar.setAttribute('aria-valuenow', data.percent);
            progressText.textContent = data.message;
            
            if (data.percent >= 15) {
                updateStatus('connected', 'Connected');
            }
        });

        socket.on('output', (data) => {
            output.textContent += data.data;
            output.scrollTop = output.scrollHeight;
        });

        socket.on('waiting_for_input', (data) => {
            showInputPrompt(data.prompt);
        });

        socket.on('execution_complete', () => {
            stopExecution();
            progressBar.style.width = '100%';
            progressText.textContent = 'Completed';
            output.textContent += '\n=== Script execution completed ===\n';
            output.scrollTop = output.scrollHeight;
        });

        socket.on('execution_stopped', () => {
            stopExecution();
            output.textContent += '\n=== Script execution stopped ===\n';
            output.scrollTop = output.scrollHeight;
        });

        socket.on('error', (data) => {
            showError(data.message);
            stopExecution();
        });

        socket.on('connect', () => {
            console.log('Connected to server');
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            if (isExecuting) {
                stopExecution();
                showError('Connection to server lost');
            }
        });
    </script>
</body>
</html>

-------------
requirements.txt

Flask==2.3.3
Flask-Session==0.5.0
Flask-SocketIO==5.3.6
paramiko==3.3.1
python-socketio==5.8.0
python-engineio==4.7.1
Werkzeug==2.3.7


pip install -r requirements.txt
