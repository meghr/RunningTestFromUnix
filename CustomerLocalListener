package com.test.listeners;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import org.testng.IExecutionListener;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;

public class HTMLReportListener implements ITestListener, IExecutionListener {

    private static final String REPORT_PATH = "test-execution-report.html";
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");

    // Use thread-safe data structures
    private static final ConcurrentHashMap<String, TestResult> testResults = new ConcurrentHashMap<>();
    private static final AtomicInteger passCount = new AtomicInteger(0);
    private static final AtomicInteger failCount = new AtomicInteger(0);
    private static final AtomicInteger skipCount = new AtomicInteger(0);
    private static final ReentrantLock reportLock = new ReentrantLock();

    // Execution time tracking
    private static volatile long suiteStartTime = 0;
    private static volatile long suiteEndTime = 0;
    private static boolean isFirstExecution = true;

    private static class TestResult {
        String suiteName;
        String testName;
        String status;
        String reason;
        long duration;
        
        public TestResult(String suiteName, String testName, String status, String reason, long duration) {
            this.suiteName = suiteName;
            this.testName = testName;
            this.status = status;
            this.reason = reason;
            this.duration = duration;
        }
    }

    @Override
    public void onStart(ITestContext context) {
        // Record start time if this is the first test
        reportLock.lock();
        try {
            if (isFirstExecution) {
                suiteStartTime = System.currentTimeMillis();
                isFirstExecution = false;
            }
        } finally {
            reportLock.unlock();
        }
    }

    @Override
    public void onFinish(ITestContext context) {
        // Update end time
        suiteEndTime = System.currentTimeMillis();
        
        // Generate the report when the tests finish
        generateReport();
    }

    @Override
    public void onTestStart(ITestResult result) {
        // We don't need to do anything here
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        String suiteName = result.getTestContext().getSuite().getName();
        String testName = result.getMethod().getMethodName();
        long duration = result.getEndMillis() - result.getStartMillis();
        
        testResults.put(getUniqueKey(result), new TestResult(suiteName, testName, "PASS", "", duration));
        passCount.incrementAndGet();
    }

    @Override
    public void onTestFailure(ITestResult result) {
        String suiteName = result.getTestContext().getSuite().getName();
        String testName = result.getMethod().getMethodName();
        String reason = result.getThrowable() != null ? result.getThrowable().getMessage() : "Unknown failure";
        long duration = result.getEndMillis() - result.getStartMillis();
        
        testResults.put(getUniqueKey(result), new TestResult(suiteName, testName, "FAIL", reason, duration));
        failCount.incrementAndGet();
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        String suiteName = result.getTestContext().getSuite().getName();
        String testName = result.getMethod().getMethodName();
        String reason = result.getThrowable() != null ? result.getThrowable().getMessage() : "Test skipped";
        long duration = 0;
        
        testResults.put(getUniqueKey(result), new TestResult(suiteName, testName, "SKIP", reason, duration));
        skipCount.incrementAndGet();
    }

    @Override
    public void onExecutionStart() {
        // If first time through, set initial start time
        reportLock.lock();
        try {
            if (suiteStartTime == 0) {
                suiteStartTime = System.currentTimeMillis();
            }
        } finally {
            reportLock.unlock();
        }
    }

    @Override
    public void onExecutionFinish() {
        // Set final end time
        suiteEndTime = System.currentTimeMillis();
        
        // Generate the report when all executions finish
        generateReport();
    }

    private void generateReport() {
        reportLock.lock();
        try {
            // Check if an existing report exists and load any previous results
            File reportFile = new File(REPORT_PATH);
            if (reportFile.exists()) {
                loadExistingReport(reportFile);
            }
            
            // Create or update the report
            StringBuilder html = new StringBuilder();
            html.append("<!DOCTYPE html>\n");
            html.append("<html lang=\"en\">\n");
            html.append("<head>\n");
            html.append("    <meta charset=\"UTF-8\">\n");
            html.append("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
            html.append("    <title>Test Execution Report</title>\n");
            html.append("    <style>\n");
            html.append("        body { font-family: Arial, sans-serif; margin: 20px; }\n");
            html.append("        .summary { background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }\n");
            html.append("        table { width: 100%; border-collapse: collapse; }\n");
            html.append("        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
            html.append("        th { background-color: #f2f2f2; }\n");
            html.append("        .pass { background-color: #dff0d8; color: #3c763d; }\n");
            html.append("        .fail { background-color: #f2dede; color: #a94442; }\n");
            html.append("        .skip { background-color: #fcf8e3; color: #8a6d3b; }\n");
            html.append("        .timestamp { font-size: 12px; color: #777; margin-top: 5px; }\n");
            html.append("    </style>\n");
            html.append("</head>\n");
            html.append("<body>\n");
            html.append("    <h1>Test Execution Report</h1>\n");
            html.append("    <div class=\"timestamp\">Generated at: " + DATE_FORMAT.format(new Date()) + "</div>\n");
            
            // Summary section
            html.append("    <h2>Summary</h2>\n");
            html.append("    <div class=\"summary\">\n");
            html.append("        <p><strong>Total Tests:</strong> " + (passCount.get() + failCount.get() + skipCount.get()) + "</p>\n");
            html.append("        <p><strong>Passed:</strong> " + passCount.get() + "</p>\n");
            html.append("        <p><strong>Failed:</strong> " + failCount.get() + "</p>\n");
            html.append("        <p><strong>Skipped:</strong> " + skipCount.get() + "</p>\n");
            
            // Only calculate duration if we have valid start and end times
            if (suiteStartTime > 0 && suiteEndTime > 0) {
                long totalDurationMillis = suiteEndTime - suiteStartTime;
                long seconds = totalDurationMillis / 1000;
                long minutes = seconds / 60;
                long hours = minutes / 60;
                seconds = seconds % 60;
                minutes = minutes % 60;
                
                html.append("        <p><strong>Total Duration:</strong> " + 
                           String.format("%02d:%02d:%02d", hours, minutes, seconds) + 
                           " (" + totalDurationMillis + " ms)</p>\n");
                
                html.append("        <p><strong>Start Time:</strong> " + DATE_FORMAT.format(new Date(suiteStartTime)) + "</p>\n");
                html.append("        <p><strong>End Time:</strong> " + DATE_FORMAT.format(new Date(suiteEndTime)) + "</p>\n");
            }
            
            html.append("    </div>\n");
            
            // Results table
            html.append("    <h2>Test Results</h2>\n");
            html.append("    <table>\n");
            html.append("        <thead>\n");
            html.append("            <tr>\n");
            html.append("                <th>Suite</th>\n");
            html.append("                <th>Test</th>\n");
            html.append("                <th>Status</th>\n");
            html.append("                <th>Duration (ms)</th>\n");
            html.append("                <th>Reason</th>\n");
            html.append("            </tr>\n");
            html.append("        </thead>\n");
            html.append("        <tbody>\n");
            
            // Add all test results
            for (TestResult result : testResults.values()) {
                String rowClass = "";
                switch (result.status) {
                    case "PASS": rowClass = "pass"; break;
                    case "FAIL": rowClass = "fail"; break;
                    case "SKIP": rowClass = "skip"; break;
                }
                
                html.append("            <tr class=\"" + rowClass + "\">\n");
                html.append("                <td>" + escapeHtml(result.suiteName) + "</td>\n");
                html.append("                <td>" + escapeHtml(result.testName) + "</td>\n");
                html.append("                <td>" + result.status + "</td>\n");
                html.append("                <td>" + result.duration + "</td>\n");
                html.append("                <td>" + escapeHtml(result.reason) + "</td>\n");
                html.append("            </tr>\n");
            }
            
            html.append("        </tbody>\n");
            html.append("    </table>\n");
            html.append("</body>\n");
            html.append("</html>");
            
            // Write the report to disk
            try (FileWriter writer = new FileWriter(REPORT_PATH)) {
                writer.write(html.toString());
            } catch (IOException e) {
                System.err.println("Error writing report: " + e.getMessage());
            }
        } finally {
            reportLock.unlock();
        }
    }
    
    private void loadExistingReport(File reportFile) {
        try {
            // This is a very simple parser to extract existing test counts
            // In a full implementation, you might want a more robust HTML parser
            String content = new String(Files.readAllBytes(Paths.get(reportFile.getPath())));
            
            // Extract existing counts if they exist
            Map<String, Integer> existingCounts = extractCounts(content);
            if (existingCounts.containsKey("passed")) {
                passCount.addAndGet(existingCounts.get("passed"));
            }
            if (existingCounts.containsKey("failed")) {
                failCount.addAndGet(existingCounts.get("failed"));
            }
            if (existingCounts.containsKey("skipped")) {
                skipCount.addAndGet(existingCounts.get("skipped"));
            }
            
            // We would also extract and merge the test results here in a full implementation
            // but for simplicity, we're just extracting the counts
            
        } catch (IOException e) {
            System.err.println("Error reading existing report: " + e.getMessage());
        }
    }
    
    private Map<String, Integer> extractCounts(String content) {
        Map<String, Integer> counts = new HashMap<>();
        
        // Very simple extraction, would need to be more robust in a real implementation
        try {
            String passedPattern = "<p><strong>Passed:</strong> ";
            String failedPattern = "<p><strong>Failed:</strong> ";
            String skippedPattern = "<p><strong>Skipped:</strong> ";
            
            int passedStart = content.indexOf(passedPattern);
            if (passedStart > 0) {
                passedStart += passedPattern.length();
                int passedEnd = content.indexOf("</p>", passedStart);
                counts.put("passed", Integer.parseInt(content.substring(passedStart, passedEnd).trim()));
            }
            
            int failedStart = content.indexOf(failedPattern);
            if (failedStart > 0) {
                failedStart += failedPattern.length();
                int failedEnd = content.indexOf("</p>", failedStart);
                counts.put("failed", Integer.parseInt(content.substring(failedStart, failedEnd).trim()));
            }
            
            int skippedStart = content.indexOf(skippedPattern);
            if (skippedStart > 0) {
                skippedStart += skippedPattern.length();
                int skippedEnd = content.indexOf("</p>", skippedStart);
                counts.put("skipped", Integer.parseInt(content.substring(skippedStart, skippedEnd).trim()));
            }
        } catch (Exception e) {
            System.err.println("Error extracting counts: " + e.getMessage());
        }
        
        return counts;
    }
    
    private String getUniqueKey(ITestResult result) {
        return result.getTestClass().getName() + "." + result.getMethod().getMethodName();
    }
    
    private String escapeHtml(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#39;");
    }
}
