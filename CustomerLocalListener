package com.test.listeners;

import org.testng.IExecutionListener;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;

import java.io.*;
import java.nio.channels.FileLock;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;

public class HTMLReportListener implements ITestListener, IExecutionListener {

    private static final String RESULTS_FILE_PATH = "test-results.txt";
    private static final String REPORT_PATH = "test-execution-report.html";
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
    private static final String DELIMITER = "|||";

    private final ConcurrentHashMap<String, TestResult> currentResults = new ConcurrentHashMap<>();
    private final AtomicInteger currentPassCount = new AtomicInteger(0);
    private final AtomicInteger currentFailCount = new AtomicInteger(0);
    private final AtomicInteger currentSkipCount = new AtomicInteger(0);
    
    private String currentSuiteName = "";
    private long suiteStartTime;
    
    private static class TestResult {
        String suiteName;
        String testName;
        String status;
        String reason;
        long duration;

        public TestResult(String suiteName, String testName, String status, String reason, long duration) {
            this.suiteName = suiteName;
            this.testName = testName;
            this.status = status;
            this.reason = reason != null ? reason : "";
            this.duration = duration;
        }

        public String toCSVLine() {
            return suiteName + DELIMITER + testName + DELIMITER + status + DELIMITER + escapeDelimiters(reason) + DELIMITER + duration;
        }

        private String escapeDelimiters(String input) {
            return input == null ? "" : input.replace(DELIMITER, "[DELIM]");
        }

        public static TestResult fromCSVLine(String line) {
            String[] parts = line.split(Pattern.quote(DELIMITER), -1);
            if (parts.length >= 5) {
                return new TestResult(parts[0], parts[1], parts[2], parts[3].replace("[DELIM]", DELIMITER), Long.parseLong(parts[4]));
            }
            return null;
        }
    }

    @Override
    public void onStart(ITestContext context) {
        suiteStartTime = System.currentTimeMillis();
        currentSuiteName = context.getSuite().getName();
        ensureFileExists(RESULTS_FILE_PATH);
    }

    @Override
    public void onFinish(ITestContext context) {
        persistCurrentExecutionData();
        generateReport();
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        recordTestResult(result, "PASS", "");
    }

    @Override
    public void onTestFailure(ITestResult result) {
        String reason = result.getThrowable() != null ? result.getThrowable().getMessage() : "Unknown failure";
        recordTestResult(result, "FAIL", reason);
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        String reason = result.getThrowable() != null ? result.getThrowable().getMessage() : "Test skipped";
        recordTestResult(result, "SKIP", reason);
    }

    private void recordTestResult(ITestResult result, String status, String reason) {
        String testName = result.getMethod().getMethodName();
        long duration = result.getEndMillis() - result.getStartMillis();
        
        currentResults.put(testName, new TestResult(currentSuiteName, testName, status, reason, duration));

        switch (status) {
            case "PASS": currentPassCount.incrementAndGet(); break;
            case "FAIL": currentFailCount.incrementAndGet(); break;
            case "SKIP": currentSkipCount.incrementAndGet(); break;
        }
    }

    private void persistCurrentExecutionData() {
        synchronized (this) {
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(RESULTS_FILE_PATH, true))) {
                for (TestResult result : currentResults.values()) {
                    writer.write(result.toCSVLine());
                    writer.newLine();
                }
            } catch (IOException e) {
                System.err.println("Error saving test results: " + e.getMessage());
            }
        }
    }

    private void generateReport() {
        List<TestResult> allResults = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(RESULTS_FILE_PATH))) {
            String line;
            while ((line = reader.readLine()) != null) {
                TestResult result = TestResult.fromCSVLine(line);
                if (result != null) {
                    allResults.add(result);
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading test results: " + e.getMessage());
        }

        StringBuilder html = new StringBuilder();
        html.append("<html><head><title>Test Execution Report</title></head><body>");
        html.append("<h1>Test Execution Report</h1>");
        html.append("<table border='1'><tr><th>Suite</th><th>Test</th><th>Status</th><th>Duration (ms)</th><th>Reason</th></tr>");

        for (TestResult result : allResults) {
            String color = result.status.equals("PASS") ? "green" : (result.status.equals("FAIL") ? "red" : "orange");
            html.append("<tr style='color:").append(color).append("'><td>")
                .append(result.suiteName).append("</td><td>")
                .append(result.testName).append("</td><td>")
                .append(result.status).append("</td><td>")
                .append(result.duration).append("</td><td>")
                .append(result.reason).append("</td></tr>");
        }

        html.append("</table></body></html>");

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(REPORT_PATH))) {
            writer.write(html.toString());
        } catch (IOException e) {
            System.err.println("Error writing report: " + e.getMessage());
        }
    }

    private void ensureFileExists(String filePath) {
        File file = new File(filePath);
        if (!file.exists()) {
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
                writer.write("");
            } catch (IOException e) {
                System.err.println("Error creating file: " + filePath);
            }
        }
    }

    @Override public void onExecutionStart() {}
    @Override public void onExecutionFinish() {}
    @Override public void onTestStart(ITestResult result) {}
}
